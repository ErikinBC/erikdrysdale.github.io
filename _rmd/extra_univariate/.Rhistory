v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
var(x)/(var(x)+var(v))
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
var(x)/(var(x)+var(v))
mdl.ols <- lm(y ~ d+x)
mdl.ols
mdl.ols <- lm(y ~ d+x)
res.y <- lm(y ~ x)$residuals
res.X1 <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.X1)
mdl.fel
mdl.fwl1
mdl.ols
se.fwl <- sqrt((1/sum(res.X1^2))*(sum(mdl.fwl1$residuals^2)/(N-(p+1))))
res.O.y <- (y - x)
res.O.d <- (d - x)
plot(res.O.y,res.y)
plot(res.O.d,res.X1)
lm(res.O.y ~ -1+res.O.d)
rm(list=ls())
sige <- 2
sigv <- 1
sigu <- 1
N <- 50
nsim <- 250
cn <- c('ols','fwl1','fwl2')
b1.store <- matrix(NA,nrow=nsim,ncol=length(cn))
colnames(b1.store) <- cn
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
mdl.ols <- lm(y ~ d+x)
res.y <- lm(y ~ x)$residuals
res.X1 <- lm(d ~ x)$residuals
rm(res.X1)
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
mdl.ols <- lm(y ~ -1+d+x)
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
.fwl1 <- lm(res.y~-1+res.d)
#
mdl.fwl1
mdl.ols
sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
summary(mdl.ols)$coef
res.O.y <- (y - x)
res.O.d <- (d - x)
plot(res.O.y,res.y)
plot(res.O.d,res.d)
lm(res.O.y ~ -1+res.O.d)
mdl.fwl2 <- lm(res.O.y ~ -1+res.O.d)
coef(mdl.ols)[2]
mdl.ols
coef(mdl.fwl1)[1]
coef(mdl.fwl2)[1]
nsim=500
for (k in 1:nsim) {
set.seed(k)
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
# --- (i) Classical regression --- #
mdl.ols <- lm(y ~ -1+d+x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
# DoF adjustment for standard error
se.fwl <- sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
# --- (iii) Oracle FWL --- #
# True residuals without X1
res.O.y <- (y - x)
# Orthogonal component of x1
res.O.d <- (d - x)
# Regression
# plot(res.O.y,res.y)
# plot(res.O.d,res.d)
mdl.fwl2 <- lm(res.O.y ~ -1+res.O.d)
# FWL w/ sample splitting?
# # FWL with know of eta
# fwl1 <- lm(I(y - (b0+b2*x2))~I(x1 - x2))
# fwl2 <- lm(I(y - (b0+b2*x2))~-1 + I(x1 - v))
# lm(I(y - b0+b2*x2) ~ I(u1+u2))
# Store
b1.ols <- coef(mdl.ols)[1]
b1.fwl1 <- coef(mdl.fwl1)[1]
b1.fwl2 <- coef(mdl.fwl2)[1]
# b1.fwl2 <- coef(fwl2)[1]
b1.store[k,] <- c(b1.ols,b1.fwl1,b1.fwl2)
if (mod(k,100)==0) print(k)
}
b1.fwl2
b1.fwl1
cn <- c('ols','fwl1','fwl2')
b1.store <- matrix(NA,nrow=nsim,ncol=length(cn))
colnames(b1.store) <- cn
# temp.list <- list()
for (k in 1:nsim) {
set.seed(k)
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
# --- (i) Classical regression --- #
mdl.ols <- lm(y ~ -1+d+x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
# DoF adjustment for standard error
se.fwl <- sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
# --- (iii) Oracle FWL --- #
# True residuals without X1
res.O.y <- (y - x)
# Orthogonal component of x1
res.O.d <- (d - x)
# Regression
# plot(res.O.y,res.y)
# plot(res.O.d,res.d)
mdl.fwl2 <- lm(res.O.y ~ -1+res.O.d)
# FWL w/ sample splitting?
# # FWL with know of eta
# fwl1 <- lm(I(y - (b0+b2*x2))~I(x1 - x2))
# fwl2 <- lm(I(y - (b0+b2*x2))~-1 + I(x1 - v))
# lm(I(y - b0+b2*x2) ~ I(u1+u2))
# Store
b1.ols <- coef(mdl.ols)[1]
b1.fwl1 <- coef(mdl.fwl1)[1]
b1.fwl2 <- coef(mdl.fwl2)[1]
# b1.fwl2 <- coef(fwl2)[1]
b1.store[k,] <- c(b1.ols,b1.fwl1,b1.fwl2)
if (mod(k,100)==0) print(k)
}
apply(b1.store,2,mean)
apply(b1.store,2,var)
coef(mdl.ols)[1]
coef(mdl.fwl1)[1]
mdl.ols <- lm(y ~ d+x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
mdl.ols
mdl.fwl1
nsim <- 500
cn <- c('ols','fwl1','fwl2')
b1.store <- matrix(NA,nrow=nsim,ncol=length(cn))
colnames(b1.store) <- cn
for (k in 1:nsim) {
set.seed(k)
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
# --- (i) Classical regression --- #
mdl.ols <- lm(y ~ d+x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
# DoF adjustment for standard error
se.fwl <- sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
# --- (iii) Oracle FWL --- #
# True residuals without X1
res.O.y <- (y - x)
# Orthogonal component of x1
res.O.d <- (d - x)
# Regression
# plot(res.O.y,res.y)
# plot(res.O.d,res.d)
mdl.fwl2 <- lm(res.O.y ~ -1+res.O.d)
# FWL w/ sample splitting?
# # FWL with know of eta
# fwl1 <- lm(I(y - (b0+b2*x2))~I(x1 - x2))
# fwl2 <- lm(I(y - (b0+b2*x2))~-1 + I(x1 - v))
# lm(I(y - b0+b2*x2) ~ I(u1+u2))
# Store
b1.ols <- coef(mdl.ols)[1]
b1.fwl1 <- coef(mdl.fwl1)[1]
b1.fwl2 <- coef(mdl.fwl2)[1]
# b1.fwl2 <- coef(fwl2)[1]
b1.store[k,] <- c(b1.ols,b1.fwl1,b1.fwl2)
if (mod(k,100)==0) print(k)
}
apply(b1.store,2,mean)
apply(b1.store,2,var)
mdl.ols
for (k in 1:nsim) {
set.seed(k)
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
# --- (i) Classical regression --- #
mdl.ols <- lm(y ~ d+x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
# DoF adjustment for standard error
se.fwl <- sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
# --- (iii) Oracle FWL --- #
# True residuals without X1
res.O.y <- (y - x)
# Orthogonal component of x1
res.O.d <- (d - x)
# Regression
# plot(res.O.y,res.y)
# plot(res.O.d,res.d)
mdl.fwl2 <- lm(res.O.y ~ -1+res.O.d)
# FWL w/ sample splitting?
# # FWL with know of eta
# fwl1 <- lm(I(y - (b0+b2*x2))~I(x1 - x2))
# fwl2 <- lm(I(y - (b0+b2*x2))~-1 + I(x1 - v))
# lm(I(y - b0+b2*x2) ~ I(u1+u2))
# Store
b1.ols <- coef(mdl.ols)[2]
b1.fwl1 <- coef(mdl.fwl1)[1]
b1.fwl2 <- coef(mdl.fwl2)[1]
# b1.fwl2 <- coef(fwl2)[1]
b1.store[k,] <- c(b1.ols,b1.fwl1,b1.fwl2)
if (mod(k,100)==0) print(k)
}
apply(b1.store,2,mean)
apply(b1.store,2,var)
dev.off()
plot(res.O.y,d+e)
lm(res.O.y`d+e)
lm(res.O.y~d+e)
all(y==x+d+e)
for (k in 1:nsim) {
set.seed(k)
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
# --- (i) Classical regression --- #
mdl.ols <- lm(y ~ d+x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
# DoF adjustment for standard error
se.fwl <- sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
# --- (iii) Oracle FWL --- #
# True residuals without X1
res.O.y <- (y - x)
# Orthogonal component of x1
res.O.d <- (d)
# Regression
# plot(res.O.y,res.y)
# plot(res.O.d,res.d)
mdl.fwl2 <- lm(res.O.y ~ -1+res.O.d)
# FWL w/ sample splitting?
# # FWL with know of eta
# fwl1 <- lm(I(y - (b0+b2*x2))~I(x1 - x2))
# fwl2 <- lm(I(y - (b0+b2*x2))~-1 + I(x1 - v))
# lm(I(y - b0+b2*x2) ~ I(u1+u2))
# Store
b1.ols <- coef(mdl.ols)[2]
b1.fwl1 <- coef(mdl.fwl1)[1]
b1.fwl2 <- coef(mdl.fwl2)[1]
# b1.fwl2 <- coef(fwl2)[1]
b1.store[k,] <- c(b1.ols,b1.fwl1,b1.fwl2)
if (mod(k,100)==0) print(k)
}
apply(b1.store,2,mean)
apply(b1.store,2,var)
lm(res.y~-1+res.d)
lm(res.y~-1+d)
lm(res.y~d)
lm(res.O.y ~ -1+res.O.d)
lm(res.O.y ~ -1+d)
lm(res.y~d)
coef(mdl.fwl3)
coef(mdl.fwl3)[2]
for (k in 1:nsim) {
set.seed(k)
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
# --- (i) Classical regression --- #
mdl.ols <- lm(y ~ d+x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
mdl.fwl3 <- lm(res.y~d)
# DoF adjustment for standard error
se.fwl <- sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
# --- (iii) Oracle FWL --- #
# True residuals without X1
res.O.y <- (y - x)
# Orthogonal component of x1
res.O.d <- (d)
# Regression
# plot(res.O.y,res.y)
# plot(res.O.d,res.d)
mdl.fwl2 <- lm(res.O.y ~ -1+res.O.d)
# FWL w/ sample splitting?
# # FWL with know of eta
# fwl1 <- lm(I(y - (b0+b2*x2))~I(x1 - x2))
# fwl2 <- lm(I(y - (b0+b2*x2))~-1 + I(x1 - v))
# lm(I(y - b0+b2*x2) ~ I(u1+u2))
# Store
b1.ols <- coef(mdl.ols)[2]
b1.fwl1 <- coef(mdl.fwl1)[1]
b1.fwl2 <- coef(mdl.fwl2)[1]
b1.fwl3 <- coef(mdl.fwl3)[2]
# b1.fwl2 <- coef(fwl2)[1]
b1.store[k,] <- c(b1.ols,b1.fwl1,b1.fwl2,b1.fwl3)
if (mod(k,100)==0) print(k)
}
nsim <- 500
cn <- c('ols','fwl1','fwl2','fwl3')
b1.store <- matrix(NA,nrow=nsim,ncol=length(cn))
colnames(b1.store) <- cn
# temp.list <- list()
for (k in 1:nsim) {
set.seed(k)
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
# --- (i) Classical regression --- #
mdl.ols <- lm(y ~ d+x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
mdl.fwl3 <- lm(res.y~d)
# DoF adjustment for standard error
se.fwl <- sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
# --- (iii) Oracle FWL --- #
# True residuals without X1
res.O.y <- (y - x)
# Orthogonal component of x1
res.O.d <- (d)
# Regression
# plot(res.O.y,res.y)
# plot(res.O.d,res.d)
mdl.fwl2 <- lm(res.O.y ~ -1+res.O.d)
# FWL w/ sample splitting?
# # FWL with know of eta
# fwl1 <- lm(I(y - (b0+b2*x2))~I(x1 - x2))
# fwl2 <- lm(I(y - (b0+b2*x2))~-1 + I(x1 - v))
# lm(I(y - b0+b2*x2) ~ I(u1+u2))
# Store
b1.ols <- coef(mdl.ols)[2]
b1.fwl1 <- coef(mdl.fwl1)[1]
b1.fwl2 <- coef(mdl.fwl2)[1]
b1.fwl3 <- coef(mdl.fwl3)[2]
# b1.fwl2 <- coef(fwl2)[1]
b1.store[k,] <- c(b1.ols,b1.fwl1,b1.fwl2,b1.fwl3)
if (mod(k,100)==0) print(k)
}
apply(b1.store,2,mean)
apply(b1.store,2,var)
lm(res.O.y ~ -1+res.O.d)
lm(res.O.y ~ -1+d)
plot(res.O.y,res.y)
lm(res.y ~ d)
lm(res.O.y ~ d)
lm(res.y ~ res.O.y)
lm(res.y ~ res.O.y)
lm(y ~ x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
# Note that the reason we can't do res.y ~ d, is because the coefficient from y ~ x has
#   positive omitted variable bias! whereas is we we (y - x)~d, there is no bias there
# DoF adjustment for standard error
se.fwl <- sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
res.O.y <- (y - x)
mdl.fwl2 <- lm(res.O.y ~ -1+d)
lm(res.O.y ~ -1+d)
lm(res.O.y ~ d)
y-(x-d)
lm(y-(x-d) ~ d)
lm(y-(x-d) ~ (d-x))
lm(I(y-(x-d)) ~ d)
lm(I(y-(x-d)) ~ I(d-x))
lm(I(y-x) ~ I(d-x))
mdl.fwl3 <- lm(I(y-x) ~ I(d-x))
mdl.fwl3 <- lm(I(y-x) ~ -1+I(d-x))
coef(mdl.fwl3)
mdl.ols
mdl.fwl1
mdl.fwl2
mdl.fwl3
for (k in 1:nsim) {
set.seed(k)
e <- rnorm(N,sd=sige)
v <- rnorm(N,sd=sigv)
x <- rnorm(N,sd=1)
# U <- matrix(rnorm(N*p,mean=0,sd=sigu),nrow=N,ncol=p)
# X <- v + U
# eta <- as.vector(cbind(1,X) %*% beta)
d <- x + v
eta <- d + x
y <- eta + e
# --- (i) Classical regression --- #
mdl.ols <- lm(y ~ d+x)
# --- (ii) Classical fwl --- #
res.y <- lm(y ~ x)$residuals
res.d <- lm(d ~ x)$residuals
mdl.fwl1 <- lm(res.y~-1+res.d)
# Note that the reason we can't do res.y ~ d, is because the coefficient from y ~ x has
#   positive omitted variable bias! whereas is we we (y - x)~d, there is no bias there
# DoF adjustment for standard error
se.fwl <- sqrt((1/sum(res.d^2))*(sum(mdl.fwl1$residuals^2)/(N-2)))
# --- (iii) Oracle FWL --- #
# True residuals without d
res.O.y <- (y - x)
mdl.fwl2 <- lm(res.O.y ~ -1+d)
mdl.fwl3 <- lm(I(y-x) ~ -1+I(d-x))
# FWL w/ sample splitting?
# # FWL with know of eta
# fwl1 <- lm(I(y - (b0+b2*x2))~I(x1 - x2))
# fwl2 <- lm(I(y - (b0+b2*x2))~-1 + I(x1 - v))
# lm(I(y - b0+b2*x2) ~ I(u1+u2))
# Store
b1.ols <- coef(mdl.ols)[2]
b1.fwl1 <- coef(mdl.fwl1)[1]
b1.fwl2 <- coef(mdl.fwl2)[1]
b1.fwl3 <- coef(mdl.fwl3)[1]
# b1.fwl2 <- coef(fwl2)[1]
b1.store[k,] <- c(b1.ols,b1.fwl1,b1.fwl2,b1.fwl3)
if (mod(k,100)==0) print(k)
}
apply(b1.store,2,mean)
apply(b1.store,2,var)
lm(I(y-x) ~ -1+I(d-x))
lm(I(y-(x-d)) ~ -1+I(d-x))
lm(I(y-x) ~ -1+I(d-x))
lm(I(y-x) ~ -1+I(d-x))
var((y-x))
var(d)
var(d-x)
lm(y ~ v)
lm(I(y-x) ~ -1+I(d-x))
lm(I(y-x) ~ v)
lm(I(y-x) ~ -1+v)
lm(I(y-x) ~ -1+I(d-x))
lm(I(y-x) ~ -1+v)
lm(I(y-x) ~ -1+v)
lm(I(y-(x-d)) ~ -1+v)
lm(I(y-(x-d)) ~ -1+d)
lm(I(y-(x-d)) ~ -1+I(d-x))
lm(I(y-(x-d)) ~ -1+I(d+x))
