cache <- forwardprop(weights,X)
loss <- fproploss(cache,delta,time)
dcache <- backprop(weights,cache,X,delta,time)
weights <- updateweights(weights,dcache,alpha)
if (((k %% 2)==0) & verbose) { print(sprintf('iter: %i, loss: %0.2f',k,loss))}
}
return(weights)
}
survnetpred <- function(snetweights,X) {
cache <- forwardprop(snetweights,X)
AL <- as.vector(cache[[length(cache)]])
return(AL)
}
m <- 1500
m <- 1500
nx <- 2
X <- matrix(rnorm(m*nx),ncol=m)
sin(X[,1]^2 + X[,2]^2)
m <- 1500
nx <- 2
X <- matrix(rnorm(m*nx),ncol=m)
sin(X[,1]^2 + X[,2]^2)
sin(X[1,]^2 + X[2,]^2)
rsk <- sin(X[1,]^2 + X[2,]^2)
df <- data.frame(t(X))
head(df)
tt <- rexp(m,rate=exp(rsk))
cc <- rexp(m)
mean(cc > tt)
cc <- rexp(m,0.1)
mean(cc > tt)
cc <- rexp(m,0.25)
mean(cc > tt)
X <- matrix(rnorm(m*nx),ncol=m)
rsk <- sin(X[1,]^2 + X[2,]^2)
tt <- rexp(m,rate=exp(rsk))
cc <- rexp(m,0.25)
delta <- ifelse(cc > tt,1,0)
set.seed(1)
X <- matrix(rnorm(m*nx),ncol=m)
rsk <- sin(X[1,]^2 + X[2,]^2)
tt <- rexp(m,rate=exp(rsk))
cc <- rexp(m,0.25)
delta <- ifelse(cc > tt,1,0)
time <- ifelse(delta==1,tt,cc)
mean(time == tt)
df <- data.frame(t(X))
trainX <- X[,1:1000]
traindf <- df[1:1000,]
testdf <- df[-(1:1000),]
head(testdf)
mdl.coxph <- coxph(So.train ~ .,data=data.frame(traindf))
So.train <- Surv(time=time[1:1000],event=delta[1:1000])
So.train <- Surv(time=time[1:1000],event=delta[1:1000])
So.test <- Surv(time=time[-(1:1000)],event=delta[-(1:1000)])
So.test[,2] %>% mean
mdl.coxph <- coxph(So.train ~ .,data=data.frame(traindf))
pred.coxph <- predict(mdl.coxph,newdata = data.frame(testdf))
length(pred.coxph)
(conc.coxph <- survConcordance(So.test ~ pred.coxph)$concordance)
dim(X.train)
dim(trainX)
dim(So.train)
mdl.snet <- survnetfit(c(3,1),trainX,So.train[,2],So.train[,1],0.1,niter=25,verbose=T)
mdl.snet <- survnetfit(c(3,1),trainX,So.train[,2],So.train[,1],1,niter=25,verbose=T)
survnetfit <- function(layer.dims,X,delta,time,alpha,niter=250,verbose=T) {
nx <- nrow(X)
weights <- weightinit(layer.dims,nx)
tord <- order(time)
time <- time[tord]
delta <- delta[tord]
X <- X[,tord]
for (k in 0:niter) {
cache <- forwardprop(weights,X)
loss <- fproploss(cache,delta,time)
dcache <- backprop(weights,cache,X,delta,time)
weights <- updateweights(weights,dcache,alpha)
if (((k %% 25)==0) & verbose) { print(sprintf('iter: %i, loss: %0.2f',k,loss))}
}
return(weights)
}
mdl.snet <- survnetfit(c(2,2,1),trainX,So.train[,2],So.train[,1],0.5,niter=25,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
trainX <- X[,1:1000]
testX <- X[,-(1:1000)]
traindf <- df[1:1000,]
testdf <- df[-(1:1000),]
So.train <- Surv(time=time[1:1000],event=delta[1:1000])
So.test <- Surv(time=time[-(1:1000)],event=delta[-(1:1000)])
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(2,2,1),trainX,So.train[,2],So.train[,1],0.1,niter=25,verbose=T)
mdl.snet <- survnetfit(c(2,2,1),trainX,So.train[,2],So.train[,1],0.1,niter=250,verbose=T)
mdl.snet <- survnetfit(c(2,2,1),trainX,So.train[,2],So.train[,1],0.01,niter=250,verbose=T)
mdl.snet <- survnetfit(c(2,2,1),trainX,So.train[,2],So.train[,1],1,niter=250,verbose=T)
mdl.snet <- survnetfit(c(2,2,1),trainX,So.train[,2],So.train[,1],10,niter=250,verbose=T)
mdl.snet <- survnetfit(c(2,1),trainX,So.train[,2],So.train[,1],0.2,niter=250,verbose=T)
mdl.snet <- survnetfit(c(10,1),trainX,So.train[,2],So.train[,1],0.2,niter=250,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(20,1),trainX,So.train[,2],So.train[,1],0.2,niter=250,verbose=T)
m <- 1500
nx <- 2
set.seed(1)
X <- matrix(rnorm(m*nx),ncol=m)
rsk <- sin(X[1,] + X[2,])
tt <- rexp(m,rate=exp(rsk))
cc <- rexp(m,0.25)
delta <- ifelse(cc > tt,1,0)
time <- ifelse(delta==1,tt,cc)
df <- data.frame(t(X))
trainX <- X[,1:1000]
testX <- X[,-(1:1000)]
traindf <- df[1:1000,]
testdf <- df[-(1:1000),]
So.train <- Surv(time=time[1:1000],event=delta[1:1000])
So.test <- Surv(time=time[-(1:1000)],event=delta[-(1:1000)])
# Cox model
mdl.coxph <- coxph(So.train ~ .,data=data.frame(traindf))
pred.coxph <- predict(mdl.coxph,newdata = data.frame(testdf))
conc.coxph <- survConcordance(So.test ~ pred.coxph)$concordance
conc.coxph
mdl.snet <- survnetfit(c(5,1),trainX,So.train[,2],So.train[,1],0.2,niter=250,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(5,3,1),trainX,So.train[,2],So.train[,1],0.2,niter=250,verbose=T)
mdl.snet <- survnetfit(c(5,5,3,1),trainX,So.train[,2],So.train[,1],0.1,niter=150,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(5,5,3,1),trainX,So.train[,2],So.train[,1],0.1,niter=450,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(10,1),trainX,So.train[,2],So.train[,1],0.1,niter=450,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(10,1),trainX,So.train[,2],So.train[,1],1,niter=150,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(10,2,1),trainX,So.train[,2],So.train[,1],1,niter=150,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
m <- 1500
nx <- 2
set.seed(1)
X <- matrix(rnorm(m*nx),ncol=m)
rsk <- sin(X[1,]^2 + X[2,]^2)
tt <- rexp(m,rate=exp(rsk))
cc <- rexp(m,0.25)
delta <- ifelse(cc > tt,1,0)
time <- ifelse(delta==1,tt,cc)
df <- data.frame(t(X))
trainX <- X[,1:1000]
testX <- X[,-(1:1000)]
traindf <- df[1:1000,]
testdf <- df[-(1:1000),]
So.train <- Surv(time=time[1:1000],event=delta[1:1000])
So.test <- Surv(time=time[-(1:1000)],event=delta[-(1:1000)])
# Cox model
mdl.coxph <- coxph(So.train ~ .,data=data.frame(traindf))
pred.coxph <- predict(mdl.coxph,newdata = data.frame(testdf))
conc.coxph <- survConcordance(So.test ~ pred.coxph)$concordance
conc.coxph
mdl.snet <- survnetfit(c(10,2,1),trainX,So.train[,2],So.train[,1],1,niter=150,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(10,10,1),trainX,So.train[,2],So.train[,1],1,niter=150,verbose=T)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
weightinit <- function(layer.dims,nx,ll) {
set.seed(1)
ldims <- c(nx,layer.dims)
L <- length(layer.dims)
weights <- list()
for (i in seq(length(layer.dims))) {
namWi <- paste('W',i,sep='')
nambi <- paste('b',i,sep='')
weights[[namWi]] <- matrix(runif(ldims[i+1]*ldims[i],-ll,ll),nrow=ldims[i+1])
weights[[nambi]] <- rep(0,ldims[i+1])
}
return(weights)
}
weightinit <- function(layer.dims,nx,ll) {
set.seed(1)
ldims <- c(nx,layer.dims)
L <- length(layer.dims)
weights <- list()
for (i in seq(length(layer.dims))) {
namWi <- paste('W',i,sep='')
nambi <- paste('b',i,sep='')
weights[[namWi]] <- matrix(runif(ldims[i+1]*ldims[i],-ll,ll),nrow=ldims[i+1])
weights[[nambi]] <- rep(0,ldims[i+1])
}
return(weights)
}
weightinit <- function(layer.dims,nx,ll=1) {
set.seed(1)
ldims <- c(nx,layer.dims)
L <- length(layer.dims)
weights <- list()
for (i in seq(length(layer.dims))) {
namWi <- paste('W',i,sep='')
nambi <- paste('b',i,sep='')
weights[[namWi]] <- matrix(runif(ldims[i+1]*ldims[i],-ll,ll),nrow=ldims[i+1])
weights[[nambi]] <- rep(0,ldims[i+1])
}
return(weights)
}
backprop <- function(weights,cache,X,delta,time,leaky=0.01) {
L <- length(weights)/2
m <- sum(delta)
dcache <- list()
for (i in seq(L,1,-1)) {
if (i == L) {
dA <- gradcoxnnet(p=cache[[paste('A',i,sep='')]],delta,time)
dZ <- dA
} else {
dA <- t(weights[[paste('W',i+1,sep='')]]) %*% dcache[[paste('dZ',i+1,sep='')]]
dZ <- dA * ifelse(cache[[paste('Z',i,sep='')]]>0,1,leaky)
}
if (i == 1) {
dW <- (1/m) * dZ %*% t(X)
} else {
dW <- (1/m) * dZ %*% t(cache[[paste('A',i-1,sep='')]])
}
db <- (1/m) * apply(dZ,1,sum)
dcache[[paste('dZ',i,sep='')]] <- dZ
dcache[[paste('dW',i,sep='')]] <- dW
dcache[[paste('db',i,sep='')]] <- db
}
return(dcache)
}
forwardprop <- function(weights,X,leaky=0.01) {
L <- length(weights)/2
cache <- list()
for (i in 1:L) {
namZi <- paste('Z',i,sep='')
namAi1 <- paste('A',i-1,sep='')
namAi <- paste('A',i,sep='')
tempW <- weights[[paste('W',i,sep='')]]
tempb <- weights[[paste('b',i,sep='')]]
if (i == 1) {
tempZ <- (tempW %*% X)
} else {
tempZ <- tempW %*% cache[[namAi1]]
}
if (i == L) {
tempA <- tempZ
} else {
tempA <- pmax(tempZ,0) + leaky*pmin(tempZ,0)
}
cache[[namZi]] <- tempZ
cache[[namAi]] <- tempA
}
return(cache)
}
survnetfit <- function(layer.dims,X,delta,time,alpha,niter=250,verbose=T,ll=1,leaky=0.01) {
nx <- nrow(X)
weights <- weightinit(layer.dims,nx,ll)
tord <- order(time)
time <- time[tord]
delta <- delta[tord]
X <- X[,tord]
for (k in 0:niter) {
cache <- forwardprop(weights,X)
loss <- fproploss(cache,delta,time)
dcache <- backprop(weights,cache,X,delta,time)
weights <- updateweights(weights,dcache,alpha)
if (((k %% 25)==0) & verbose) { print(sprintf('iter: %i, loss: %0.2f',k,loss))}
}
return(weights)
}
forwardprop %>% args
survnetpred <- function(snetweights,X,leaky) {
cache <- forwardprop(snetweights,X,leaky)
AL <- as.vector(cache[[length(cache)]])
return(AL)
}
mdl.snet <- survnetfit(c(5,1),trainX,So.train[,2],So.train[,1],1,niter=150,verbose=T,ll=1,leaky=0.01)
mdl.snet <- survnetfit(c(5,1),trainX,So.train[,2],So.train[,1],1,niter=150,verbose=T,ll=1,leaky=0.1)
mdl.snet <- survnetfit(c(5,1),trainX,So.train[,2],So.train[,1],1,niter=150,verbose=T,ll=0.1,leaky=0.1)
mdl.snet <- survnetfit(c(5,4,3,2,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=150,verbose=T,ll=0.1,leaky=0.1)
mdl.snet <- survnetfit(c(5,4,3,2,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=150,verbose=T,ll=0.1,leaky=0.25)
mdl.snet <- survnetfit(c(5,4,3,2,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=150,verbose=T,ll=1,leaky=0.25)
mdl.snet <- survnetfit(c(20,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=150,verbose=T,ll=1,leaky=0.25)
mdl.snet <- survnetfit(c(10,2,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=150,verbose=T,ll=1,leaky=0.25)
pred.snet <- survnetpred(mdl.snet,testX)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(2,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=150,verbose=T,ll=1,leaky=0.25)
mdl.snet <- survnetfit(c(2,2,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=150,verbose=T,ll=1,leaky=0.25)
mdl.snet <- survnetfit(c(2,2,2,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=75,verbose=T,ll=1,leaky=0.25)
mdl.snet <- survnetfit(c(2,2,2,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=75,verbose=T,ll=1/2,leaky=0.25)
mdl.snet <- survnetfit(c(2,2,2,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
mdl.snet <- survnetfit(c(2,2,2,1),trainX,So.train[,2],So.train[,1],alpha = 0.1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
mdl.snet <- survnetfit(c(2,2,2,1),trainX,So.train[,2],So.train[,1],alpha = 10,
niter=75,verbose=T,ll=1/2,leaky=0.1)
mdl.snet <- survnetfit(c(2,10,1),trainX,So.train[,2],So.train[,1],alpha = 0.1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
mdl.snet <- survnetfit(c(2,10,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(2,5,10,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
mdl.snet <- survnetfit(c(50,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(50,50,1),trainX,So.train[,2],So.train[,1],alpha = 1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(50,25,1),trainX,So.train[,2],So.train[,1],alpha = 0.1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(10,1),trainX,So.train[,2],So.train[,1],alpha = 0.1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
m <- 1500
nx <- 2
set.seed(1)
X <- matrix(rnorm(m*nx),ncol=m)
rsk <- (X[1,]^2 + X[2,]^2)
tt <- rexp(m,rate=exp(rsk))
cc <- rexp(m,0.25)
delta <- ifelse(cc > tt,1,0)
time <- ifelse(delta==1,tt,cc)
df <- data.frame(t(X))
trainX <- X[,1:1000]
testX <- X[,-(1:1000)]
traindf <- df[1:1000,]
testdf <- df[-(1:1000),]
So.train <- Surv(time=time[1:1000],event=delta[1:1000])
So.test <- Surv(time=time[-(1:1000)],event=delta[-(1:1000)])
# Cox model
mdl.coxph <- coxph(So.train ~ .,data=data.frame(traindf))
pred.coxph <- predict(mdl.coxph,newdata = data.frame(testdf))
conc.coxph <- survConcordance(So.test ~ pred.coxph)$concordance
conc.coxph
m <- 1500
nx <- 2
set.seed(1)
X <- matrix(rnorm(m*nx),ncol=m)
rsk <- (X[1,]^2 + X[2,]^2)
tt <- rexp(m,rate=exp(rsk))
cc <- rexp(m,0.25)
delta <- ifelse(cc > tt,1,0)
time <- ifelse(delta==1,tt,cc)
df <- data.frame(t(X))
trainX <- X[,1:1000]
testX <- X[,-(1:1000)]
traindf <- df[1:1000,]
testdf <- df[-(1:1000),]
So.train <- Surv(time=time[1:1000],event=delta[1:1000])
So.test <- Surv(time=time[-(1:1000)],event=delta[-(1:1000)])
# Cox model
mdl.coxph <- coxph(So.train ~ .,data=data.frame(traindf))
pred.coxph <- predict(mdl.coxph,newdata = data.frame(testdf))
mdl.coxph
mdl.snet <- survnetfit(c(10,1),trainX,So.train[,2],So.train[,1],alpha = 0.1,
niter=75,verbose=T,ll=1/2,leaky=0.1)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
m <- 1500
nx <- 2
set.seed(1)
X <- matrix(rnorm(m*nx),ncol=m)
df <- data.frame(t(X))
rsk <- (df$X1^2 + df$X2^2)
tt <- rexp(m,rate=exp(rsk))
cc <- rexp(m,0.25)
delta <- ifelse(cc > tt,1,0)
time <- ifelse(delta==1,tt,cc)
trainX <- X[,1:1000]
testX <- X[,-(1:1000)]
traindf <- df[1:1000,]
testdf <- df[-(1:1000),]
So.train <- Surv(time=time[1:1000],event=delta[1:1000])
So.test <- Surv(time=time[-(1:1000)],event=delta[-(1:1000)])
coxph(So.train ~ .,data=data.frame(traindf))
coxph(So.train ~ .,data=data.frame(traindf))
coxph(So.train ~ I(X1) + I(X2) .,data=data.frame(traindf))
coxph(So.train ~ I(X1) + I(X2) ,data=data.frame(traindf))
coxph(So.train ~ I(X1**2) + I(X2**2) ,data=data.frame(traindf))
mdl.snet <- survnetfit(c(10,1),trainX,So.train[,2],So.train[,1],alpha = 0.1,
niter=150,verbose=T,ll=1/2,leaky=0.1)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(10,5,1),trainX,So.train[,2],So.train[,1],alpha = 0.1,
niter=150,verbose=T,ll=1/2,leaky=0.1)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
mdl.snet <- survnetfit(c(10,5,1),trainX,So.train[,2],So.train[,1],alpha = 0.1,
niter=500,verbose=T,ll=1/2,leaky=0.1)
pred.snet <- survnetpred(mdl.snet,testX,leaky=0.25)
conc.snet <- survConcordance(So.test ~ pred.snet)$concordance
c(conc.coxph,conc.snet)
print(sprintf('Concordance scores for Cox-PH: %0.3f and neural network: %0.3f',conc.coxph,conc.snet))
rm(list=ls())
rmd2md <- function( path_site = getwd(),
dir_rmd = "_rmd",
dir_md = "_posts",
#dir_images = "figures",
url_images = "figures/",
out_ext='.md',
in_ext='.rmd',
recursive=FALSE) {
require(knitr, quietly=TRUE, warn.conflicts=FALSE)
#andy change to avoid path problems when running without sh on windows
files <- list.files(path=file.path(path_site,dir_rmd), pattern=in_ext, ignore.case=TRUE, recursive=recursive)
for(f in files) {
message(paste("Processing ", f, sep=''),encoding = "UTF-8")
content <- readLines(file.path(path_site,dir_rmd,f))
# If any html calls, replace the src=figures/... with src=/figures/...
src.idx <- grep('src=',content,value=F)
if (length(src.idx)>0) {
content[src.idx] <- gsub('src=\"figures','src=\"/figures',content[src.idx])
} else {}
frontMatter <- which(substr(content, 1, 3) == '---')
if(length(frontMatter) >= 2 & 1 %in% frontMatter) {
statusLine <- which(substr(content, 1, 7) == 'status:')
publishedLine <- which(substr(content, 1, 10) == 'published:')
if(statusLine > frontMatter[1] & statusLine < frontMatter[2]) {
status <- unlist(strsplit(content[statusLine], ':'))[2]
status <- sub('[[:space:]]+$', '', status)
status <- sub('^[[:space:]]+', '', status)
if(tolower(status) == 'process') {
#This is a bit of a hack but if a line has zero length (i.e. a
#black line), it will be removed in the resulting markdown file.
#This will ensure that all line returns are retained.
content[nchar(content) == 0] <- ' '
message(paste('Processing ', f, sep=''))
content[statusLine] <- 'status: publish'
content[publishedLine] <- 'published: true'
#andy change to path
outFile <- file.path(path_site, dir_md, paste0(substr(f, 1, (nchar(f)-(nchar(in_ext)))), out_ext))
#render_markdown(strict=TRUE)
#render_markdown(strict=FALSE) #code didn't render properly on blog
#andy change to render for jekyll
render_jekyll(highlight = "pygments")
#render_jekyll(highlight = "prettify") #for javascript
opts_knit$set(out.format='markdown')
# andy BEWARE don't set base.dir!! it caused me problems
# "base.dir is never used when composing the URL of the figures; it is
# only used to save the figures to a different directory.
# The URL of an image is always base.url + fig.path"
# https://groups.google.com/forum/#!topic/knitr/18aXpOmsumQ
# Get data directory
opts_knit$set(root.dir = dir_rmd)
opts_knit$set(base.url = "/")
# opts_knit$set(fig.width = 10)
opts_chunk$set(fig.path = url_images)
# opts_chunk$set(fig.width = 10)
#andy I could try to make figures bigger
#but that might make not work so well on mobile
opts_chunk$set(fig.width  = 8.5,
fig.height = 7.5,
dpi=300)
try(knit(text=content, output=outFile,encoding = "UTF-8"), silent=FALSE)
} else {
warning(paste("Not processing ", f, ", status is '", status,
"'. Set status to 'process' to convert.", sep=''))
}
} else {
warning("Status not found in front matter.")
}
} else {
warning("No front matter found. Will not process this file.")
}
}
invisible()
}
setwd("C:/Users/erikinwest/Documents/blogs/github/erikdrysdale.github.io/")
rmd2md()
setwd("C:/Users/erikinwest/Documents/blogs/github/erikdrysdale.github.io/")
rmd2md()
setwd("C:/Users/erikinwest/Documents/blogs/github/erikdrysdale.github.io/")
rmd2md()
