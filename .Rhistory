data.frame(ortho = lasso.ortho, actual = lasso.actual)
lam <- 1.0
lasso.ortho <- soft(ols2, lam)
lasso.actual <- coef(glmnet(x=X.pc.s,y=y,'gaussian',lambda=lam,intercept = F, standardize = F))[-1]
data.frame(ortho = lasso.ortho, actual = lasso.actual)
lasso.orig.x <- coef(glmnet(x=x.s,y=y,'gaussian',lambda=lam,intercept = F, standardize = F))[-1]
# zero out the PC projections that are zero
W2 <- W.pc.s
which(lasso.orig.x  == 0)
coef(glmnet(x=x.s,y=y,'gaussian',lambda=lam,intercept = F, standardize = F))
# zero out the PC projections that are zero
W2 <- W.pc.s
W2[which(lasso.orig.x  == 0), ] <- 0
# Then project
lasso.orig.x.hat <- W2 %*% (lasso.actual / scale.pc.s)
data.frame(orig.x = lasso.orig.x, hat = lasso.orig.x.hat)
gram.s <- t(x.s) %*% x.s
inv.gram.s <- solve(gram.s)
W.pc.s %*% inv.gram.s %*% (lasso.ortho / scale.pc.s)
lasso.orig.x.hat
W.pc.s %*% inv.gram.s %*% (lasso.ortho
)
apply(x.s,2,sd)
apply(X.pc.s,2,sd)
t(x.s) %*% x.s
diag(t(x.s) %*% x.s)
lasso.orig.x.hat
diag(W.pc.s %*% inv.gram.s)
diag(W.pc.s %*% inv.gram.s) %>% sort()
diag(W.pc.s %*% inv.gram.s) %>% abs %>% sort()
sort(W.pc.s %*% inv.gram.s %*% (lasso.ortho / scale.pc.s))
W.pc.s %*% inv.gram.s %*% (lasso.ortho / scale.pc.s)
lasso.ortho
lasso.ortho
lasso.ortho
W.pc.s %*% lasso.ortho
W.pc.s %*% lasso.ortho
W.pc.s %*% inv.gram.s %*% lasso.ortho
W.pc.s %*% inv.gram.s %*% lasso.ortho
lasso.orig.x.hat
W.pc.s %*% inv.gram.s %*% lasso.ortho
lasso.orig.x.hat
W.pc.s %*% inv.gram.s %*% lasso.ortho
W.pc.s %*% inv.gram.s %*% lasso.ortho / scale.pc.s
librar(data.table
)
library(data.table)
data.table(W.pc.s %*% inv.gram.s %*% lasso.ortho / scale.pc.s)
q1=W.pc.s %*% inv.gram.s %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)
data.table(var=rownames(q1),q1)[order(abs(q1))]
lasso.orig.x.hat
q1=W.pc.s %*% inv.gram.s %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)[order(-abs(q1))]
lasso.orig.x.hat
order(lasso.orig.x.hat)
lasso.orig.x.hat[order(lasso.orig.x.hat),]
lasso.orig.x.hat[order(abs(lasso.orig.x.hat)),]
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
data.table(var=rownames(q1),q1)[order(-abs(q1))]
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
lasso.ortho
lasso.actual
lasso.ortho
q1=W.pc.s %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)[order(-abs(q1))]
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
q1=W.pc.s %*% gram.s %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)[order(-abs(q1))]
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
q1=W.pc.s %*% inv.gram.s %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)[order(-abs(q1))]
lasso.ortho
W.pc.s
lasso.ortho!=0
W.pc.s[lasso.ortho!=0,lasso.ortho!=0]
W.pc.s[,lasso.ortho!=0]
lasso.ortho!=0
W.pc.s[lasso.ortho!=0,lasso.ortho!=0]
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
W.pc.s[,lasso.ortho!=0]
W.pc.s[,lasso.ortho!=0] %>% dim
inv.gram.s %*% W.pc.s[,lasso.ortho!=0]
dim(inv.gram.s %*% W.pc.s[,lasso.ortho!=0])
lasso.ortho
lasso.ortho
W.pc.s[,lasso.ortho!=0] %*% t(W.pc.s[,lasso.ortho!=0])
Xtilde <- x.s %*% W.pc.s[,lasso.ortho!=0] %*% t(W.pc.s[,lasso.ortho!=0])
diag(t(Xtilde) %*% Xtilde)
gram2 <- t(Xtilde) %*% Xtilde
inv.gram2 <- solve(gram2)
inv.gram2 <- ginv(gram2)
q1=W.pc.s %*% inv.gram.s %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)[order(-abs(q1))]
q1=W.pc.s %*% inv.gram.s2 %*% lasso.ortho / scale.pc.s
q1=W.pc.s %*% inv.gram2 %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)[order(-abs(q1))]
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
q1=W.pc.s %*% gram2 %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)[order(-abs(q1))]
q1=W.pc.s %*% inv.gram2 %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)[order(-abs(q1))]
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
W.pc.s %*% inv.gram.s %*% (lasso.ortho / scale.pc.s)
MASS::birthwt %>% head
MASS::Cars93 %>% head
MASS::Melanoma %>% head
psych::affect
MASS::survey
n <- 100
p <- 50
set.seed(1)
X <- matrix(rnorm(n*p),ncol=p)
bvec <- c(rep(0.5,p/2),rep(0,p))
bve
bve
bve
bvec**2
sum(bvec**2)
u <- rnorm(n,sd=sqrt(2))
n <- 100
p <- 50
set.seed(1)
X <- matrix(rnorm(n*p),ncol=p)
bvec <- c(rep(0.5,p/2),rep(0,p))
u <- rnorm(n,sd=sqrt(2))
eta <- as.vector(X %*% bvec)
y <- eta + u
bvec <- c(rep(0.5,p/2),rep(0,p/2))
eta <- as.vector(X %*% bvec)
y <- eta + u
# de-mean
y.mu <- y - mean(y)
x.mu <- scale(x,center = T, scale = F)
x.s <- scale(x,center = T, scale = T)
# dimensions
n <- nrow(x)
p <- ncol(x)
# PCs
pc.mu <- prcomp(x.mu)$x
pc.s <- prcomp(x.s)
X.pc.s <- pc.s$x
W.pc.s <- pc.s$rotation
scale.pc.s <- apply(X.pc.s,2,function(cc) sqrt(sum(cc * cc) /n ) )
X.pc.s <- sweep(X.pc.s, 2, scale.pc.s, '/')
diag(t(X.pc.s) %*% X.pc.s)
n
rm(list=ls())
n <- 100
p <- 50
set.seed(1)
n <- 100
p <- 50
set.seed(1)
x <- matrix(rnorm(n*p),ncol=p)
bvec <- c(rep(0.5,p/2),rep(0,p/2))
u <- rnorm(n,sd=sqrt(2))
eta <- as.vector(X %*% bvec)
y <- eta + u
# y <- MASS::Boston[,14] # mtcars[,1]
# x <- as.matrix(MASS::Boston[,-14]) # as.matrix(mtcars[,-1])
eta <- as.vector(x %*% bvec)
y <- eta + u
# y <- MASS::Boston[,14] # mtcars[,1]
# x <- as.matrix(MASS::Boston[,-14]) # as.matrix(mtcars[,-1])
# de-mean
y.mu <- y - mean(y)
x.mu <- scale(x,center = T, scale = F)
x.s <- scale(x,center = T, scale = T)
# dimensions
n <- nrow(x)
p <- ncol(x)
# PCs
pc.mu <- prcomp(x.mu)$x
pc.s <- prcomp(x.s)
X.pc.s <- pc.s$x
W.pc.s <- pc.s$rotation
scale.pc.s <- apply(X.pc.s,2,function(cc) sqrt(sum(cc * cc) /n ) )
X.pc.s <- sweep(X.pc.s, 2, scale.pc.s, '/')
diag(t(X.pc.s) %*% X.pc.s)
ols1 <- coef(lm( y.mu ~ -1 + x.s))
ols2 <- coef(lm( y.mu ~ -1 + X.pc.s))
# Re-scale
ols1.hat <- W.pc.s %*% (ols2 / scale.pc.s)
data.frame(ols1,ols2,ols1.hat)
data.frame(ols1,ols2,ols1.hat) %>% head
soft <- function(x,t) { sign(x) * pmax(abs(x) - t, 0) }
lam <- 1.0
lasso.ortho <- soft(ols2, lam)
lasso.actual <- coef(glmnet(x=X.pc.s,y=y,'gaussian',lambda=lam,intercept = F, standardize = F))[-1]
data.frame(ortho = lasso.ortho, actual = lasso.actual)
data.frame(ortho = lasso.ortho, actual = lasso.actual) %>% head(10)
ols2
lam <- 0.25
lasso.ortho <- soft(ols2, lam)
lasso.actual <- coef(glmnet(x=X.pc.s,y=y,'gaussian',lambda=lam,intercept = F, standardize = F))[-1]
data.frame(ortho = lasso.ortho, actual = lasso.actual) %>% head(10)
lasso.ortho[1:25]
lasso.ortho[-(1:26)]
lasso.ortho[-(1:25)]
lasso.orig.x <- coef(glmnet(x=x.s,y=y,'gaussian',lambda=lam,intercept = F, standardize = F))[-1]
# zero out the PC projections that are zero
W2 <- W.pc.s
W2[which(lasso.orig.x  == 0), ] <- 0
# Then project
lasso.orig.x.hat <- W2 %*% (lasso.actual / scale.pc.s)
data.frame(orig.x = lasso.orig.x, hat = lasso.orig.x.hat)
gram.s <- t(x.s) %*% x.s
inv.gram.s <- solve(gram.s)
Xtilde <- x.s %*% W.pc.s[,lasso.ortho!=0] %*% t(W.pc.s[,lasso.ortho!=0])
gram2 <- t(Xtilde) %*% Xtilde
inv.gram2 <- ginv(gram2)
q1=W.pc.s %*% inv.gram2 %*% lasso.ortho / scale.pc.s
data.table(var=rownames(q1),q1)[order(-abs(q1))]
q1
lasso.orig.x.hat
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
colnames(x) <- paste0('var',1:p)
rm(list=ls())
n <- 100
p <- 50
set.seed(1)
x <- matrix(rnorm(n*p),ncol=p)
colnames(x) <- paste0('var',1:p)
bvec <- c(rep(0.5,p/2),rep(0,p/2))
u <- rnorm(n,sd=sqrt(2))
eta <- as.vector(x %*% bvec)
y <- eta + u
# y <- MASS::Boston[,14] # mtcars[,1]
# x <- as.matrix(MASS::Boston[,-14]) # as.matrix(mtcars[,-1])
# de-mean
y.mu <- y - mean(y)
x.mu <- scale(x,center = T, scale = F)
x.s <- scale(x,center = T, scale = T)
# dimensions
n <- nrow(x)
p <- ncol(x)
# PCs
pc.mu <- prcomp(x.mu)$x
pc.s <- prcomp(x.s)
X.pc.s <- pc.s$x
W.pc.s <- pc.s$rotation
scale.pc.s <- apply(X.pc.s,2,function(cc) sqrt(sum(cc * cc) /n ) )
X.pc.s <- sweep(X.pc.s, 2, scale.pc.s, '/')
diag(t(X.pc.s) %*% X.pc.s)
#########################################
# Q1: Can we recover the OLS coefficients from the least squares regression on the PCs?
ols1 <- coef(lm( y.mu ~ -1 + x.s))
ols2 <- coef(lm( y.mu ~ -1 + X.pc.s))
# Re-scale
ols1.hat <- W.pc.s %*% (ols2 / scale.pc.s)
data.frame(ols1,ols2,ols1.hat) %>% head
# A1: Yes: (i) run a PC on the scaled x data, (ii) re-scale the PC,
#         (iii) run OLS on rescaled PCs, (iv) multiple projection weights on (iii) divided by se from (ii)
############################################
# Q2: When orthogonal X, can we get the closed form Lasso?
# soft threshold
soft <- function(x,t) { sign(x) * pmax(abs(x) - t, 0) }
lam <- 0.25
lasso.ortho <- soft(ols2, lam)
lasso.actual <- coef(glmnet(x=X.pc.s,y=y,'gaussian',lambda=lam,intercept = F, standardize = F))[-1]
data.frame(ortho = lasso.ortho, actual = lasso.actual) %>% head(10)
# A2: Yes it can, with an orthogonal design we can compute it with the soft-thresholding
###################################
# Q3: If we knew the true active set for the non-PC regression, could we use the PC least squares to recover?
lasso.orig.x <- coef(glmnet(x=x.s,y=y,'gaussian',lambda=lam,intercept = F, standardize = F))[-1]
# zero out the PC projections that are zero
W2 <- W.pc.s
W2[which(lasso.orig.x  == 0), ] <- 0
# Then project
lasso.orig.x.hat <- W2 %*% (lasso.actual / scale.pc.s)
data.frame(orig.x = lasso.orig.x, hat = lasso.orig.x.hat)
# A3: Not quite
########################################################
# Q4: Usin the inverse of the gram matrix, the Lasso PC, and the PC projection, can we predict the support?
gram.s <- t(x.s) %*% x.s
inv.gram.s <- solve(gram.s)
Xtilde <- x.s %*% W.pc.s[,lasso.ortho!=0] %*% t(W.pc.s[,lasso.ortho!=0])
gram2 <- t(Xtilde) %*% Xtilde
inv.gram2 <- ginv(gram2)
q1=W.pc.s %*% inv.gram2 %*% lasso.ortho / scale.pc.s
names(q1)
q1
rownames(q1)
data.table(var=rownames(q1),q1)[order(-abs(q1))]
data.table(var=rownames(q1),q1)[order(-abs(q1))] %>% head(10)
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
lasso.orig.x.hat[order(-abs(lasso.orig.x.hat)),]
lasso.orig.x.hat
lasso.orig.x.hat!=0
which(lasso.orig.x.hat!=0)
names(lasso.orig.x.hat)
rownames(lasso.orig.x.hat)
rownames(lasso.orig.x.hat)[which(lasso.orig.x.hat!=0)]
tmp <- data.table(var=rownames(q1),q1)[order(-abs(q1))]
tmp[, is_supp := ifelse(var %in% rownames(lasso.orig.x.hat)[which(lasso.orig.x.hat!=0)],T,F)]
tmp
tmp[order(-abs(V1))]
data.table(var=rownames(q1),q1)[order(-abs(q1))]
q1
W.pc.s
W.pc.s[,lasso.ortho!=0]
lasso.ortho
lasso.ortho!=0
which(lasso.ortho!=0)
W.pc.s[,lasso.ortho!=0]
dim(W.pc.s[,lasso.ortho!=0])
W.pc.s[,lasso.ortho!=0] %*% lasso.ortho
W.pc.s[,lasso.ortho!=0] %*% lasso.ortho[lasso.ortho != 0]
q1 <- W.pc.s[,lasso.ortho!=0] %*% lasso.ortho[lasso.ortho != 0]
names(lasso.ortho[lasso.ortho != 0])
lasso.orig.x !=0
which(lasso.orig.x !=0 )
lasso.orig.x
true.supp <- which(lasso.orig.x !=0 )
q1 <- W.pc.s[,lasso.ortho!=0] %*% lasso.ortho[lasso.ortho != 0]
head(q1)
lasso.ortho
q1 <- W.pc.s[,lasso.ortho!=0] %*% lasso.ortho[lasso.ortho != 0] / scale.pc.s
head(q1)
true.supp
X.pc.s <- pc.s$x
W.pc.s <- pc.s$rotation
# scale.pc.s <- apply(X.pc.s,2,function(cc) sqrt(sum(cc * cc) /n ) )
# X.pc.s <- sweep(X.pc.s, 2, scale.pc.s, '/')
diag(t(X.pc.s) %*% X.pc.s)
ols2
max(abs(ols2))
# lasso.actual <-
coef(glmnet(x=X.pc.s,y=y,'gaussian',lambda=1.1,intercept = F, standardize = F))[-1]
# lasso.actual <-
coef(glmnet(x=X.pc.s,y=y,'gaussian',lambda=1.2,intercept = F, standardize = F))[-1]
# lasso.orig.x <-
coef(glmnet(x=x.s,y=y,'gaussian',lambda=1.2,intercept = F, standardize = F))[-1]
apply(X.pc.s,2,sd)
X.pc.s <- pc.s$x
W.pc.s <- pc.s$rotation
scale.pc.s <- apply(X.pc.s,2,function(cc) sqrt(sum(cc * cc) /n ) )
X.pc.s <- sweep(X.pc.s, 2, scale.pc.s, '/')
apply(X.pc.s,2,sd)
lam <- 0.25
lasso.ortho <- soft(ols2, lam)
ols2
#########################################
# Q1: Can we recover the OLS coefficients from the least squares regression on the PCs?
ols1 <- coef(lm( y.mu ~ -1 + x.s))
ols2 <- coef(lm( y.mu ~ -1 + X.pc.s))
# Re-scale
ols1.hat <- W.pc.s %*% (ols2 / scale.pc.s)
data.frame(ols1,ols2,ols1.hat) %>% head
# A1: Yes: (i) run a PC on the scaled x data, (ii) re-scale the PC,
max(abs(ols2))
# lasso.actual <-
coef(glmnet(x=X.pc.s,y=y,'gaussian',lambda=1.2,intercept = F, standardize = F))[-1]
t(x.s) %*% y
t(x.s) %*% y / n
max(abs(t(x.s) %*% y / n))
# lasso.orig.x <-
coef(glmnet(x=x.s,y=y,'gaussian',lambda=1.2,intercept = F, standardize = F))[-1]
rm(list=ls())
# x <- matrix(rnorm(n*p),ncol=p)
# colnames(x) <- paste0('var',1:p)
# bvec <- c(rep(0.5,p/2),rep(0,p/2))
# u <- rnorm(n,sd=sqrt(2))
# eta <- as.vector(x %*% bvec)
# y <- eta + u
rm(list=ls())
# n <- 100
# p <- 50
# set.seed(1)
# x <- matrix(rnorm(n*p),ncol=p)
# colnames(x) <- paste0('var',1:p)
# bvec <- c(rep(0.5,p/2),rep(0,p/2))
# u <- rnorm(n,sd=sqrt(2))
# eta <- as.vector(x %*% bvec)
# y <- eta + u
y <- MASS::Boston[,14] # mtcars[,1]
x <- as.matrix(MASS::Boston[,-14]) # as.matrix(mtcars[,-1])
xinv <- MASS:ginv()
xinv <- MASS::ginv(x)
x <- scale(as.matrix(MASS::Boston[,-14])) # as.matrix(mtcars[,-1])
xinv <- MASS::ginv(t(x) %*% x)
xinv %*% t(x) %*% y
lm ( y ~ x)
y <- scale(MASS::Boston[,14],scale = F) # mtcars[,1]
x <- scale(as.matrix(MASS::Boston[,-14])) # as.matrix(mtcars[,-1])
xinv <- MASS::ginv(t(x) %*% x)
xinv %*% t(x) %*% y
xinv %*% t(x) %*% y
lm ( y ~ x)
lm ( y ~-1+ x)
xinv %*% t(x) %*% y
lm ( y ~-1+ x)
ols <- xinv %*% t(x) %*% y
g <- sign(ols)
xinv %*% g
ols - (xinv %*% g)
lam <- 0.25
ols - (xinv %*% g)*
# de-mean
y.mu <- y - mean(y)
ols - (xinv %*% g)*lam
(xinv %*% g)*lam
ols
ols - (xinv %*% g / n)*lam
sign()
sign((xinv %*% g)*lam)
sign(ols) == sign((xinv %*% g))
sign(ols)
sign((xinv %*% g))
sign(ols) == sign((xinv %*% g))
lam <- 0.25
g <- sign(ols)
g
ols
abs(ols) > lam
ifelse(abs(ols) > lam,sign(ols),0)
g <- ifelse(abs(ols) > lam,sign(ols),0)
ols - (xinv %*% g)*lam
coef(glmnet::glmnet(x,y,'gaussian',lambda = 0.25))
coef(glmnet::glmnet(x,y,'gaussian',lambda = 0.25,intercept = F,scale=F))
coef(glmnet::glmnet(x,y,'gaussian',lambda = 0.25,intercept = F,standardize=F))
ols
coef(glmnet::glmnet(x,y,'gaussian',lambda = 0.25,intercept = F,standardize=F))
coef(glmnet::glmnet(x,y,'gaussian',lambda = 0.25,intercept = F,standardize=F,alpha=0))
ols
coef(glmnet::glmnet(x,y,'gaussian',lambda = 0.5,intercept = F,standardize=F))
ols
coef(glmnet::glmnet(x,y,'gaussian',lambda = 0.1,intercept = F,standardize=F,alpha=0))
coef(glmnet::glmnet(x,y,'gaussian',lambda = 1,intercept = F,standardize=F,alpha=0))
library(survival)
Surv(time=0,time2=2,event=1)
Surv(time=0,time2=2,event=0)
rm(list=ls())
rmd2md <- function( path_site = getwd(),
dir_rmd = "_rmd",
dir_md = "_posts",
#dir_images = "figures",
url_images = "figures/",
out_ext='.md',
in_ext='.rmd',
recursive=FALSE) {
require(knitr, quietly=TRUE, warn.conflicts=FALSE)
#andy change to avoid path problems when running without sh on windows
files <- list.files(path=file.path(path_site,dir_rmd), pattern=in_ext, ignore.case=TRUE, recursive=recursive)
for(f in files) {
message(paste("Processing ", f, sep=''),encoding = "UTF-8")
content <- readLines(file.path(path_site,dir_rmd,f))
# If any html calls, replace the src=figures/... with src=/figures/...
src.idx <- grep('src=',content,value=F)
if (length(src.idx)>0) {
content[src.idx] <- gsub('src=\"figures','src=\"/figures',content[src.idx])
} else {}
frontMatter <- which(substr(content, 1, 3) == '---')
if(length(frontMatter) >= 2 & 1 %in% frontMatter) {
statusLine <- which(substr(content, 1, 7) == 'status:')
publishedLine <- which(substr(content, 1, 10) == 'published:')
if(statusLine > frontMatter[1] & statusLine < frontMatter[2]) {
status <- unlist(strsplit(content[statusLine], ':'))[2]
status <- sub('[[:space:]]+$', '', status)
status <- sub('^[[:space:]]+', '', status)
if(tolower(status) == 'process') {
#This is a bit of a hack but if a line has zero length (i.e. a
#black line), it will be removed in the resulting markdown file.
#This will ensure that all line returns are retained.
content[nchar(content) == 0] <- ' '
message(paste('Processing ', f, sep=''))
content[statusLine] <- 'status: publish'
content[publishedLine] <- 'published: true'
#andy change to path
outFile <- file.path(path_site, dir_md, paste0(substr(f, 1, (nchar(f)-(nchar(in_ext)))), out_ext))
#render_markdown(strict=TRUE)
#render_markdown(strict=FALSE) #code didn't render properly on blog
#andy change to render for jekyll
render_jekyll(highlight = "pygments")
#render_jekyll(highlight = "prettify") #for javascript
opts_knit$set(out.format='markdown')
# andy BEWARE don't set base.dir!! it caused me problems
# "base.dir is never used when composing the URL of the figures; it is
# only used to save the figures to a different directory.
# The URL of an image is always base.url + fig.path"
# https://groups.google.com/forum/#!topic/knitr/18aXpOmsumQ
# Get data directory
opts_knit$set(root.dir = dir_rmd)
opts_knit$set(base.url = "/")
# opts_knit$set(fig.width = 10)
opts_chunk$set(fig.path = url_images)
# opts_chunk$set(fig.width = 10)
#andy I could try to make figures bigger
#but that might make not work so well on mobile
opts_chunk$set(fig.width  = 8.5,
fig.height = 7.5,
dpi=300)
try(knit(text=content, output=outFile,encoding = "UTF-8"), silent=FALSE)
} else {
warning(paste("Not processing ", f, ", status is '", status,
"'. Set status to 'process' to convert.", sep=''))
}
} else {
warning("Status not found in front matter.")
}
} else {
warning("No front matter found. Will not process this file.")
}
}
invisible()
}
setwd("C:/Users/erikinwest/Documents/blogs/github/erikdrysdale.github.io/")
rmd2md()
rmd2md()
rmd2md()
rmd2md()
